package Item23;


// Item 23 : 태그 달린 클래스보다는 클래스 계층 구조를 활용하라
public class Main {
    public static void main(String[] args){

        // 두가지 이상의 의미를 표현할 수 있으며, 그 중 현재 표현하는 의미를 태그 값으로 알려주는 클래스
        Figure rectangle = new Figure(1, 2);
        Figure circle = new Figure(2);
        System.out.println(circle.shape);
        System.out.println(rectangle.shape);

        // 태그 달린 클래스의 단점
        // 1. 열거 타입 선언, 태그 필드, switch 문 등 쓸데없는 코드가 너무 많다.
        // 2. 여러 구현이 한 클래스에 혼합되어 가독성도 나쁘다.
        // 3. 다른 의미를 위한 코드도 함께하니 메모리도 많이 사용된다.
        // -> Rectangle 을 만들어도 Circle의 필드가 있어 메모리 차지
        // 4. 필드들을 final로 선언하려면 사용하지 않는 필드들도 초기화해야해서 불필요한 코드가 증가하다.
        // 5. 생성자에서 데이터 필드들을 초기화할 때, 컴파일러의 도움을 받지 못한다.
        // -> 엉뚱한 필드를 초기화해도 런타임시에 들어난다.
        // 6. 또 다른 의미를 추가하려면 코드를 수정해야 한다. - switch 문 수정
        // 7. 인스턴스의 타입만으로는 현재 나타내는 의미를 알수가 없다.
        // -> Figure이 Rectangle인지 Circle인지 알 수가 없다.

        // 정리 : "태그 달린 클래스는 장황하고 오류를 내기 쉽고 비효율적이다."


        // 해결책 : 서브 타이핑을 사용하자.
        // -> 타입 하나로 다양한 의미의 객체를 표현하는 수단
        // -> 클래스 계층 구조를 활용하는 방법
        // "태그 클래스는 계층 구조를 어설프게 흉내낸 것이다"

        // 태그 클래스를 계층구조로 만드는 방법
        // 1. 계층구조의 루트가 될 추상 클래스 정의
        // 2. 태그 값에 따라 달라질 메서드들을 루트 클래스의 추상메서드로 정의
        // 3. 태그 값에 관계없이 동작이 일정한 메서드들을 루트 클래스의 일반 메서드로 추가
        // 4. 하위 클래스에서 공통으로 사용하는 필드들을 전부 루트 클래스에 추가
        // 5. 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의

        // Figure 적용
        // -> Figure의 Area 메서드를 추상메서드로 정의
        // -> Circle, Rectangle 클래스 생성
        newCircle circle1 = new newCircle(1);
        newRectangle rectangle1 = new newRectangle(1, 2);

        // 변화점
        // 1. 열거타입 선언, 태그 필드, switch 문 모두 제거 됨
        // 2. 가독성이 좋아짐
        // 3. 필요없는 필드들 제거
        // 4. final로 선언 가능
        // 5. 초기화시 컴파일 도움도 받는다. -> 추상 메서드를 모두 구현했는지 등에 대한 여부
        // 6. switch 문 수정 필요가 없다.
        // 7. 의미 파악이 쉬움


        // 정리
        // 태그 달린 클래스를 사용하지말고 이를 계층 구조로 만들자.
        // 이미 사용중이라면 리팩토링해서 계층구조로 만들자.


    }
}
