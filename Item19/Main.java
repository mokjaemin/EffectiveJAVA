package Item19;


import java.util.*;

// Item 19 : 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
public class Main {
    public static void main(String[] args){

        // 문서화하지 않은 '외부' 클래스를 상속할 때는 위험하다.
        // -> 프로그래머의 통제권 밖에 있기 때문에 언제 어떻게 변경될지 모르기 때문이다.



        // 1. 상속을 고려한 설계와 문서화 규칙

        // - 1. 메서드를 재정의하면 어떤 일이 일어나는지에 대해 정리하여 문서로 남겨야 한다.
        // -> 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
        // -> 예시 : API로 공개된 메서드 호출시 해당 메서드 내부에서 호출되는 다른 메서드가 재정의 메서드인 경우 등
        // -> 어떤 순서로 호출되는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.
        // -> "재정의 기능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다."
        // -> API 실제 문서에서는 Implementation Requirements 부분이 메서드 내부 동작 방식을 설명하는 부분
        // -> 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성
        // -> 해당 태그 활성화 방법은 -tag "implSpec:a Implementation Requirements:" 를 지정
        // "안전하게 해당 클래스를 상속할 수 있게 하려면 내부 구현 방식을 설명해야 한다"
        Calculator test1 = new Calculator();


        // - 2. 클래스의 내부 동작 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수 있다.
        // -> 예시 : 개발자는 protected AbstractList의 removeRange 메서드를 사용하지 않지만
        // 재정의시 claer 메서드 속도 향상
        // -> 어떤 메서드를 protected 로 설정해야 하나? 하위 클래스를 만들어보며 직접 필요여부 확인
        // -> 상속용 클래스는 반드시 하위 클래스로 만들어 점검을 해야한다.
        TestList<Integer> testList = new TestList<>();
        testList.add(0);
        testList.add(1);
        testList.clear();


        // - 3. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 기능 메서드를 호출해서는 안된다.
        // -> 어길시 프로그램 오작동
        // -> 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스의 재정의 메서드가
        // 하위 클래스의 생성자보다 먼저 실행되게 된다. 즉, 하위 클래스가 생성되기도 전에 하위 클래스의 메서드가 실행된다.
        // -> 아래의 경우, 하위 객체를 생성하면서 상위 클래스의 생성자도 호출되기에 두번의 인스턴스를 호출할것 같지만 아니다.
        Sub sub = new Sub();
        sub.overrideMe();
        // -> Cloneable 또는 Serializable 인터페이스를 구현한 클래스는 상속받지 말아야 한다.
        // -> clone과 readObject 메서드가 생성자와 같이 새로운 객체를 생성하고
        // 이 때, 직간접적으로 재정의 메서드들을 호출할 수 있기 때문에


        // 2. 상속화를 위해 설계가 안되어 있거나 API가 잘 작성이 안되어 있는 구체 클래스는 상속을 금지시켜라
        // - 1. 클래스를 final로 선언
        // - 2. 모든 생성자를 private이나 package-private(지정자 생략)로 설정 후 public 정적 팩터리 제공
        // 두 방법 다 좋다.

        // (+)
        // 인터페이스를 구현해 만든 클래스는 상속을 금지시켜도 문제는 없다
        // 래퍼 클래스 패턴은 상속에 다른 대안이다.

        // 인터페이스를 구현하지 않은 클래스의 상속을 허용시키는 방법
        // - 하위 클래스에서 재정의 기능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것












    }
}
